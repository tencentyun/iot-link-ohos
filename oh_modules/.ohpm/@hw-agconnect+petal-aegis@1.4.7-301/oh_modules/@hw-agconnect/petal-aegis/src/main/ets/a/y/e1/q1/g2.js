import cryptoFramework from '@ohos.security.cryptoFramework'; import { AegisError } from "../../../s/t"; import { AegisErrorCode } from "../../../s/u"; import { CipherHandler } from "../b2"; import { CipherInfoCenter } from "../y1"; const NUM_BITS_OF_BYTE = 8; function getSegmentSize(mode, h3, i3) { if (mode === cryptoFramework.CryptoMode.ENCRYPT_MODE) { return h3 / NUM_BITS_OF_BYTE - i3 / NUM_BITS_OF_BYTE * 2 - 2; } else { return h3 / NUM_BITS_OF_BYTE; } } export class AsyCipherHandler extends CipherHandler { constructor(g3, mode, key) { super(g3); this.mode = mode; this.key = key; } rsaPreProcess() { let b3 = CipherInfoCenter.load(this.cipherAlg); if (!b3.nBits || !b3.hashBits) { return; } if (this.inputs.length !== 1) { return; } let c3 = getSegmentSize(this.mode, b3.nBits, b3.hashBits); if (this.inputs[0].length <= c3) { return; } let d3 = this.inputs[0]; let e3 = Math.floor(d3.length / c3); let f3 = d3.length % c3; this.inputs = []; let start = 0; for (let index = 0; index < e3; index++) { this.inputs.push(d3.slice(start, start + c3)); start += c3; } if (f3 > 0) { this.inputs.push(d3.slice(start)); } } checkInputLen(a3, input) { if (!a3.plainTextMaxLen || !a3.cipherTextMaxLen) { return; } if (this.mode === cryptoFramework.CryptoMode.ENCRYPT_MODE) { if (input.length > a3.plainTextMaxLen) { throw new AegisError(AegisErrorCode.PARAM_INVALID, `plainText is too large, max len is ${a3.plainTextMaxLen}`); } } else { if (input.length > a3.cipherTextMaxLen) { throw new AegisError(AegisErrorCode.PARAM_INVALID, `cipherText is too large, max len is ${a3.cipherTextMaxLen}`); } } } async doCrypto(t2, u2) { this.rsaPreProcess(); let v2 = CipherInfoCenter.load(this.cipherAlg); let w2 = cryptoFramework.createCipher(v2.transformation[0]); await w2.init(this.mode, this.key, null); for (let input of this.inputs) { this.checkInputLen(v2, input); let z2 = await w2.doFinal({ data: input }); t2 === null || t2 === void 0 ? void 0 : t2.push(z2.data); u2.push(...z2.data); } } } 