import cryptoFramework from '@ohos.security.cryptoFramework'; import { AegisError } from "../../../s/t"; import { AegisErrorCode } from "../../../s/u"; import { AsyKeyBuilder } from "../../z/f2"; import { KeyConverter } from "../../z/c1"; import { Cipher } from "../f1"; import { CipherInfoCenter } from "../y1"; import { AsyCipherHandler } from "./g2"; export class AsyCipher extends Cipher { constructor(r2, s2) { super(r2); this.encryptHandler = new AsyCipherHandler(r2, cryptoFramework.CryptoMode.ENCRYPT_MODE, s2.pubKey); this.decryptHandler = new AsyCipherHandler(r2, cryptoFramework.CryptoMode.DECRYPT_MODE, s2.priKey); } static builder() { return new AsyCipherBuilder(); } } class AsyCipherBuilder extends AsyKeyBuilder { withCipherAlg(q2) { this.cipherAlg = q2; return this; } static j(o2) { if (!o2) { throw new AegisError(AegisErrorCode.PARAM_INVALID, 'invalid cipher alg'); } } getKeyType() { let n2 = CipherInfoCenter.load(this.cipherAlg); AsyCipherBuilder.j(n2); return n2.keyType; } getRSANBits() { var l2; let m2 = CipherInfoCenter.load(this.cipherAlg); AsyCipherBuilder.j(m2); return (l2 = m2.nBits) !== null && l2 !== void 0 ? l2 : KeyConverter.DEFAULT_RSA_N_BITS; } async build() { await this.initKeys(); return new AsyCipher(this.cipherAlg, this.keyPair); } } 