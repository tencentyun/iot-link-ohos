import cryptoFramework from '@ohos.security.cryptoFramework'; import cryptoCert from '@ohos.security.cert'; import { KeyType, SymKeyLen } from "./a1"; import { Coder } from "../s1/t1"; import { KeyInfoCenter } from "./k2"; import { AegisError } from "../../s/t"; import { AegisErrorCode } from "../../s/u"; const ITEM_NOT_EXIST_INDEX = -1; const HEX_RADIX = 16; const BITS_MULTIPLE_FOR_HEX_STR = 4; const HMAC_KEY_ALG_NAME = 'HMAC'; const AES_KEY_ALG_MAP = new Map([ [SymKeyLen.AES_128, 'AES128'], [SymKeyLen.AES_192, 'AES192'], [SymKeyLen.AES_256, 'AES256'] ]); export class KeyConverter { static async fromKeyPair(n5, priKey, pubKey) { let keyInfo = KeyInfoCenter.load(n5); if (!keyInfo) { throw new AegisError(AegisErrorCode.BAD_KEY_TYPE, 'invalid key pair type'); } let o5 = cryptoFramework.createAsyKeyGenerator(keyInfo.algName); let p5 = await o5.convertKey(pubKey ? { data: pubKey } : null, priKey ? { data: priKey } : null); return p5; } static async fromRSAKeyPair(priKey, pubKey) { return await KeyConverter.fromKeyPair(KeyType.RSA_3072_PRIMES_2, priKey, pubKey); } static async fromECKeyPair(priKey, pubKey) { return await KeyConverter.fromKeyPair(KeyType.ECC_256, priKey, pubKey); } static getRSANBitsOfKey(key) { try { let n = key.getAsyKeySpec(cryptoFramework.AsyKeySpecItem.RSA_N_BN); let m5 = n.toString(HEX_RADIX); return m5.length * BITS_MULTIPLE_FOR_HEX_STR; } catch (err) { return KeyConverter.DEFAULT_RSA_N_BITS; } } static async fromSM2KeyPair(priKey, pubKey) { return await KeyConverter.fromKeyPair(KeyType.SM2_256, priKey, pubKey); } static async fromPKCS8PriKey(k5, l5) { return await KeyConverter.fromKeyPair(k5, l5, null); } static async fromX509PubKey(i5, j5) { return await this.fromKeyPair(i5, null, j5); } static checkAESKeyLen(h5) { let len = [SymKeyLen.AES_128, SymKeyLen.AES_192, SymKeyLen.AES_256]; if (len.indexOf(h5 === null || h5 === void 0 ? void 0 : h5.length) === ITEM_NOT_EXIST_INDEX) { throw new AegisError(AegisErrorCode.PARAM_INVALID, 'invalid aes key len'); } } static async fromSymKey(e5) { var f5; let g5 = cryptoFramework.createSymKeyGenerator((f5 = AES_KEY_ALG_MAP.get(e5.length)) !== null && f5 !== void 0 ? f5 : HMAC_KEY_ALG_NAME); return await g5.convertKey({ data: e5 }); } static async fromCertPEM(d5) { return await cryptoCert.createX509Cert({ data: Coder.UTF8.decode(d5), encodingFormat: cryptoCert.EncodingFormat.FORMAT_PEM }); } static async fromCertDER(c5) { return await cryptoCert.createX509Cert({ data: c5, encodingFormat: cryptoCert.EncodingFormat.FORMAT_DER }); } } KeyConverter.DEFAULT_RSA_N_BITS = 0; 