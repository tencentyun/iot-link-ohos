import type cryptoFramework from '@ohos.security.cryptoFramework'; import type huks from '@ohos.security.huks'; import type { KeyType } from "../z/a1"; export declare enum CipherAlg { AES_GCM_NO_PADDING = 0, AES_CBC_PKCS7_PADDING = 1, AES_CBC_PKCS5_PADDING = 2, AES_CTR_NO_PADDING = 3, AES_OFB_NO_PADDING = 4, AES_CCM_NO_PADDING = 5, AES_CFB_NO_PADDING = 6, RSA_OAEP_SHA256_MGF1_SHA256 = 10, SM4_CBC_PKCS7_PADDING = 20, SM4_CBC_PKCS5_PADDING = 21, SM4_CTR_NO_PADDING = 22, SM4_OFB_NO_PADDING = 23, SM4_CFB_NO_PADDING = 24, SM4_CFB128_NO_PADDING = 25, SM2_256_SHA256 = 31, SM2_256_SHA384 = 32, SM2_256_SHA512 = 33, SM2_256_SM3 = 34, HUKS_AES_GCM_256_NO_PADDING = 41 } export interface CipherParamsSpec extends cryptoFramework.ParamsSpec { iv: cryptoFramework.DataBlob; blockMaxSize?: number; aad?: cryptoFramework.DataBlob; authTagLen?: number; authTag?: cryptoFramework.DataBlob; keyType?: KeyType; huksCryptoMode?: huks.HuksKeyPurpose; } export declare function getTransformationIndexFromKey(key: cryptoFramework.SymKey): number; declare type CryptoOptionsFunc = (paramsSpec: CipherParamsSpec) => huks.HuksOptions; export interface CipherInfo { transformation?: Array<string>; ivLen?: number; authTagLen?: number; keyType?: KeyType; paramsSpecAlgName?: string; nBits?: number; hashBits?: number; optionsFunc?: CryptoOptionsFunc; plainTextMaxLen?: number; cipherTextMaxLen?: number; } export {}; 