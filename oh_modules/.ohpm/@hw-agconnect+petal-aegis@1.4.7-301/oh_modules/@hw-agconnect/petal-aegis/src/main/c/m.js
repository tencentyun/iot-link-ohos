import { AESCipher, CipherAlg, Coder, KeyManager, KeyType } from "../ets/a/b"; import { AegLogger } from "./c2/d2"; import { SafeRandom } from "./e"; import { getStrOrUint8ToUint8, uint8ArraytoHexString, uint8ArrayToString } from "./q/s2"; export class AegHuks { static async ohAegHuksEncText(keyAlias, text, iv) { return new Promise(async (r19, s19) => { try { let t19 = getStrOrUint8ToUint8(text); AegHuks.ohAegHuksEnc(keyAlias, t19, iv).then((data) => { return r19(data); }).catch((err) => { AegLogger.error(AegHuks.TAG, 'ohAegHuksEncText ohAegHuksEnc fail, err code: ' + err.code + ', err msg: ' + err.message); return s19(err); }); } catch (err) { AegLogger.error(AegHuks.TAG, 'ohAegHuksEncText fail, err code: ' + err.code + ', err msg: ' + err.message); return s19(err); } }); } static async ohAegHuksDecText(keyAlias, j19) { return new Promise(async (l19, m19) => { try { AegHuks.ohAegHuksDec(keyAlias, j19).then((data) => { let p19 = uint8ArrayToString(data); return l19(p19); }).catch((err) => { AegLogger.error(AegHuks.TAG, 'ohAegHuksDecText ohAegHuksDec fail, err code: ' + err.code + ', err msg: ' + err.message); return m19(err); }); } catch (err) { AegLogger.error(AegHuks.TAG, 'ohAegHuksDecText fail, err code: ' + err.code + ', err msg: ' + err.message); return m19(err); } }); } static async ohAegHuksEncTextHex(keyAlias, text, iv) { return new Promise(async (e19, f19) => { try { let g19 = getStrOrUint8ToUint8(text); AegHuks.ohAegHuksEncHex(keyAlias, g19, iv).then((data) => { return e19(data); }).catch((err) => { AegLogger.error(AegHuks.TAG, 'ohAegHuksEncText ohAegHuksEnc fail, err code: ' + err.code + ', err msg: ' + err.message); return f19(err); }); } catch (err) { AegLogger.error(AegHuks.TAG, 'ohAegHuksEncText fail, err code: ' + err.code + ', err msg: ' + err.message); return f19(err); } }); } static async ohAegHuksDecTextHex(keyAlias, w18) { return new Promise(async (y18, z18) => { try { AegHuks.ohAegHuksDec(keyAlias, w18).then((data) => { let c19 = uint8ArrayToString(data); return y18(c19); }).catch((err) => { AegLogger.error(AegHuks.TAG, 'ohAegHuksDecTextHex ohAegHuksDec fail, err code: ' + err.code + ', err msg: ' + err.message); return z18(err); }); } catch (err) { AegLogger.error(AegHuks.TAG, 'ohAegHuksDecTextHex fail, err code: ' + err.code + ', err msg: ' + err.message); return z18(err); } }); } static async ohAegHuksEncHex(keyAlias, text, iv) { return new Promise(async (p18, q18) => { try { let r18 = new Uint8Array(); if (iv) { r18 = AegHuks.getUint8Array(iv); } else { r18 = SafeRandom.ohAegRandom(AegHuks.IV_LEN); } let s18 = AegHuks.getUint8Array(text); let t18 = await AESCipher .builder() .withCipherAlg(CipherAlg.HUKS_AES_GCM_256_NO_PADDING) .withKeyAlias(keyAlias) .withIv(r18) .build(); t18.getEncryptHandler() .from(s18) .toHex() .then((data) => { let result = Coder.HEX.encode(r18) + ':' + data; p18(result); }) .catch((err) => { AegLogger.error(AegHuks.TAG, 'ohAegHuksEncHex getEncryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); q18(err); }); } catch (err) { AegLogger.error(AegHuks.TAG, 'ohAegHuksEncHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); q18(err); } }); } static async ohAegHuksEnc(keyAlias, text, iv) { return new Promise(async (g18, h18) => { try { let i18 = new Uint8Array(); if (iv) { i18 = AegHuks.getUint8Array(iv); } else { i18 = SafeRandom.ohAegRandom(AegHuks.IV_LEN); } let j18 = AegHuks.getUint8Array(text); let k18 = await AESCipher .builder() .withCipherAlg(CipherAlg.HUKS_AES_GCM_256_NO_PADDING) .withKeyAlias(keyAlias) .withIv(i18) .build(); k18.getEncryptHandler() .from(j18) .to() .then((data) => { let n18 = Coder.UTF8.decode(':'); let result = new Uint8Array(i18.length + data.length + n18.length); result.set(i18, 0); result.set(n18, i18.length); result.set(data, i18.length + n18.length); g18(result); }) .catch((err) => { AegLogger.error(AegHuks.TAG, 'ohAegHuksEnc getEncryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); h18(err); }); } catch (err) { AegLogger.error(AegHuks.TAG, 'ohAegHuksEnc parse fail, err code: ' + err.code + ', err msg: ' + err.message); h18(err); } }); } static async ohAegHuksDecHex(keyAlias, text) { return new Promise(async (a18, b18) => { try { AegHuks.ohAegHuksDec(keyAlias, text).then((data) => { let e18 = uint8ArraytoHexString(data); a18(e18); }).catch((err) => { AegLogger.error(AegHuks.TAG, 'ohAegHuksDecHex getDecryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); b18(err); }); } catch (err) { AegLogger.error(AegHuks.TAG, 'ohAegHuksDecHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); b18(err); } }); } static async ohAegHuksDec(keyAlias, text) { return new Promise(async (q17, r17) => { try { let s17 = AegHuks.getCiphertextUint8Array(text); let t17 = await AESCipher .builder() .withCipherAlg(CipherAlg.HUKS_AES_GCM_256_NO_PADDING) .withKeyAlias(keyAlias) .withIv(s17.iv) .build(); t17.getDecryptHandler() .from(s17.text) .to() .then((data) => { return q17(data); }) .catch(async (err) => { let w17 = await AESCipher .builder() .withCipherAlg(CipherAlg.HUKS_AES_GCM_256_NO_PADDING) .withKeyAlias(keyAlias) .withIv(s17.iv) .withAad(new Uint8Array(4)) .build(); w17.getDecryptHandler() .from(s17.text) .to() .then((data) => { return q17(data); }) .catch((err) => { AegLogger.error(AegHuks.TAG, 'ohAegHuksDec getDecryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); return r17(err); }); }); } catch (err) { AegLogger.error(AegHuks.TAG, 'ohAegHuksDec parse fail, err code: ' + err.code + ', err msg: ' + err.message); return r17(err); } }); } static async ohAegHasHuksKey(keyAlias) { return new Promise(async (l17, m17) => { try { KeyManager.hasHuksKey(KeyType.HUKS_AES_GCM_256, keyAlias).then((data) => { l17(data); }).catch((err) => { AegLogger.error(AegHuks.TAG, 'ohAegHasHuksKey hasHuksKey fail, err code: ' + err.code + ', err msg: ' + err.message); m17(false); }); } catch (err) { AegLogger.error(AegHuks.TAG, 'ohAegHasHuksKey parse fail, err code: ' + err.code + ', err msg: ' + err.message); m17(false); } }); } static async ohAegDelHuksKey(keyAlias) { return new Promise(async (g17, h17) => { try { KeyManager.deleteHuksKey(KeyType.HUKS_AES_GCM_256, keyAlias).then(() => { AegLogger.error(AegHuks.TAG, 'ohAegDelHuksKey hasHuksKey code'); g17(true); }).catch((err) => { AegLogger.error(AegHuks.TAG, 'ohAegDelHuksKey hasHuksKey fail, err code: ' + err.code + ', err msg: ' + err.message); h17(err); }); } catch (err) { AegLogger.error(AegHuks.TAG, 'ohAegDelHuksKey parse fail, err code: ' + err.code + ', err msg: ' + err.message); h17(err); } }); } static getUint8Array(input) { if (input instanceof Uint8Array) { return input; } else { return Coder.HEX.decode(input); } } static getCiphertextUint8Array(input) { if (input instanceof Uint8Array) { let iv = input.subarray(0, AegHuks.IV_LEN); let e17 = input.subarray(AegHuks.IV_LEN + 1, input.length); return new Ciphertext(iv, e17); } else { let iv = Coder.HEX.decode(input.substring(0, AegHuks.IV_LEN * 2)); let d17 = Coder.HEX.decode(input.substring((AegHuks.IV_LEN * 2) + 1, input.length)); return new Ciphertext(iv, d17); } } } AegHuks.TAG = 'aegis AegHuks'; AegHuks.IV_LEN = 12; export class Ciphertext { constructor(iv, text) { this.iv = iv; this.text = text; } } 