import { AESCipher, CipherAlg, Coder } from "../ets/a/b"; import { AegLogger } from "./c2/d2"; import { SafeRandom } from "./e"; import { getStrOrUint8ToUint8, uint8ArrayToString } from "./q/s2"; export class AegSM { static async ohAegSMEncText(text, key, iv) { return new Promise(async (w38, x38) => { try { let y38 = getStrOrUint8ToUint8(text); AegSM.ohAegSMEnc(y38, key, iv).then((data) => { return w38(data); }).catch((err) => { AegLogger.error(AegSM.TAG, 'ohAegSMEncText ohAegSMEnc fail, err code: ' + err.code + ', err msg: ' + err.message); return x38(err); }); } catch (err) { AegLogger.error(AegSM.TAG, 'ohAegSMEncText fail, err code: ' + err.code + ', err msg: ' + err.message); return x38(err); } }); } static async ohAegSMDecText(o38, key) { return new Promise(async (q38, r38) => { try { AegSM.ohAegSMDec(o38, key).then((data) => { let u38 = uint8ArrayToString(data); return q38(u38); }).catch((err) => { AegLogger.error(AegSM.TAG, 'ohAegSMDecText ohAegSMDec fail, err code: ' + err.code + ', err msg: ' + err.message); return r38(err); }); } catch (err) { AegLogger.error(AegSM.TAG, 'ohAegSMDecText fail, err code: ' + err.code + ', err msg: ' + err.message); return r38(err); } }); } static async ohAegSMEncTextHex(text, key, iv) { return new Promise(async (j38, k38) => { try { let l38 = getStrOrUint8ToUint8(text); AegSM.ohAegSMEncHex(l38, key, iv).then((data) => { return j38(data); }).catch((err) => { AegLogger.error(AegSM.TAG, 'ohAegSMEncText ohAegSMEncHex fail, err code: ' + err.code + ', err msg: ' + err.message); return k38(err); }); } catch (err) { AegLogger.error(AegSM.TAG, 'ohAegSMEncText fail, err code: ' + err.code + ', err msg: ' + err.message); return k38(err); } }); } static async ohAegSMDecTextHex(b38, key) { return new Promise(async (d38, e38) => { try { AegSM.ohAegSMDec(b38, key).then((data) => { let h38 = uint8ArrayToString(data); return d38(h38); }).catch((err) => { AegLogger.error(AegSM.TAG, 'ohAegSMDecTextHex ohAegSMDec fail, err code: ' + err.code + ', err msg: ' + err.message); return e38(err); }); } catch (err) { AegLogger.error(AegSM.TAG, 'ohAegSMDecTextHex fail, err code: ' + err.code + ', err msg: ' + err.message); return e38(err); } }); } static async ohAegSMEncHex(text, key, iv) { return new Promise(async (t37, u37) => { try { let v37 = new Uint8Array(); if (iv) { v37 = AegSM.getUint8Array(iv); } else { v37 = SafeRandom.ohAegRandom(AegSM.IV_LEN); } let w37 = AegSM.getUint8Array(text); let x37 = AegSM.getUint8Array(key); let y37 = await AESCipher .builder() .withCipherAlg(CipherAlg.SM4_CBC_PKCS7_PADDING) .withKeyBytes(x37) .withIv(v37) .build(); y37.getEncryptHandler().from(w37).toHex().then((data) => { let result = Coder.HEX.encode(v37) + ':' + data; t37(result); }).catch((err) => { AegLogger.error(AegSM.TAG, 'ohAegSMEncHex getEncryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); u37(err); }); } catch (err) { AegLogger.error(AegSM.TAG, 'ohAegSMEncHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); u37(err); } }); } static async ohAegSMEnc(text, key, iv) { return new Promise(async (j37, k37) => { try { let l37 = new Uint8Array(); if (iv) { l37 = AegSM.getUint8Array(iv); } else { l37 = SafeRandom.ohAegRandom(AegSM.IV_LEN); } let m37 = AegSM.getUint8Array(text); let n37 = AegSM.getUint8Array(key); let o37 = await AESCipher .builder() .withCipherAlg(CipherAlg.SM4_CBC_PKCS7_PADDING) .withKeyBytes(n37) .withIv(l37) .build(); o37.getEncryptHandler().from(m37).to().then((data) => { let r37 = Coder.UTF8.decode(':'); let result = new Uint8Array(l37.length + data.length + r37.length); result.set(l37, 0); result.set(r37, l37.length); result.set(data, l37.length + r37.length); j37(result); }).catch((err) => { AegLogger.error(AegSM.TAG, 'ohAegSMEnc getEncryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); k37(err); }); } catch (err) { AegLogger.error(AegSM.TAG, 'ohAegSMEnc parse fail, err code: ' + err.code + ', err msg: ' + err.message); k37(err); } }); } static async ohAegSMDecHex(text, key) { return new Promise(async (b37, c37) => { try { let d37 = AegSM.getCiphertextUint8Array(text); let e37 = AegSM.getUint8Array(key); let f37 = await AESCipher .builder() .withCipherAlg(CipherAlg.SM4_CBC_PKCS7_PADDING) .withKeyBytes(e37) .withIv(d37.iv) .build(); f37.getDecryptHandler().from(d37.text).toHex().then((data) => { b37(data); }).catch((err) => { AegLogger.error(AegSM.TAG, 'ohAegSMDecHex getDecryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); c37(err); }); } catch (err) { AegLogger.error(AegSM.TAG, 'ohAegSMDecHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); c37(err); } }); } static async ohAegSMDec(text, key) { return new Promise(async (t36, u36) => { try { let v36 = AegSM.getCiphertextUint8Array(text); let w36 = AegSM.getUint8Array(key); let x36 = await AESCipher .builder() .withCipherAlg(CipherAlg.SM4_CBC_PKCS7_PADDING) .withKeyBytes(w36) .withIv(v36.iv) .build(); x36.getDecryptHandler().from(v36.text).to().then((data) => { t36(data); }).catch((err) => { AegLogger.error(AegSM.TAG, 'ohAegSMDec getDecryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); u36(err); }); } catch (err) { AegLogger.error(AegSM.TAG, 'ohAegSMDec parse fail, err code: ' + err.code + ', err msg: ' + err.message); u36(err); } }); } static getUint8Array(input) { if (input instanceof Uint8Array) { return input; } else { return Coder.HEX.decode(input); } } static getCiphertextUint8Array(input) { if (input instanceof Uint8Array) { let iv = input.subarray(0, AegSM.IV_LEN); let r36 = input.subarray(AegSM.IV_LEN + 1, input.length); return new Ciphertext(iv, r36); } else { let iv = Coder.HEX.decode(input.substring(0, AegSM.IV_LEN * 2)); let q36 = Coder.HEX.decode(input.substring((AegSM.IV_LEN * 2) + 1, input.length)); return new Ciphertext(iv, q36); } } } AegSM.TAG = 'aegis AegSM'; AegSM.IV_LEN = 16; export class Ciphertext { constructor(iv, text) { this.iv = iv; this.text = text; } } 