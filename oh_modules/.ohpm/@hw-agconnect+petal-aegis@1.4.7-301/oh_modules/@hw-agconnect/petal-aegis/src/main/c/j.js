import { AsyCipher, CipherAlg, Coder, KeyManager, KeyType } from "../ets/a/b"; import { AegLogger } from "./c2/d2"; import { getStrOrUint8ToUint8, uint8ArrayToString } from "./q/s2"; export class AegRsa { static async ohAegGenerateRsaKeyPairBase64() { return new Promise(async (j33, k33) => { try { KeyManager.generateKeyPair(KeyType.RSA_3072_PRIMES_2).then((n33) => { let o33 = Coder.BASE64.encode(n33.priKey.getEncoded().data); let p33 = Coder.BASE64.encode(n33.pubKey.getEncoded().data); j33(new Rsa(p33, o33)); }).catch((err) => { AegLogger.error(AegRsa.TAG, 'ohAegGenerateRsaKeyPair generateKeyPair fail, err code: ' + err.code + ', err msg: ' + err.message); k33(err); }); } catch (err) { AegLogger.error(AegRsa.TAG, 'ohAegGenerateRsaKeyPair parse fail, err code: ' + err.code + ', err msg: ' + err.message); k33(err); } }); } static async ohAegGenerateRsaKeyPair() { return new Promise(async (b33, c33) => { try { KeyManager.generateKeyPair(KeyType.RSA_3072_PRIMES_2).then((f33) => { let g33 = f33.priKey.getEncoded().data; let h33 = f33.pubKey.getEncoded().data; b33(new Rsa(h33, g33)); }).catch((err) => { AegLogger.error(AegRsa.TAG, 'ohAegGenerateRsaKeyPair generateKeyPair fail, err code: ' + err.code + ', err msg: ' + err.message); c33(err); }); } catch (err) { AegLogger.error(AegRsa.TAG, 'ohAegGenerateRsaKeyPair parse fail, err code: ' + err.code + ', err msg: ' + err.message); c33(err); } }); } static async ohAegRsaEncText(text, pubKey) { return new Promise(async (v32, w32) => { try { let x32 = getStrOrUint8ToUint8(text); AegRsa.ohAegRsaEnc(x32, pubKey).then((data) => { return v32(data); }).catch((err) => { AegLogger.error(AegRsa.TAG, 'ohAegRsaEncText ohAegRsaEnc fail, err code: ' + err.code + ', err msg: ' + err.message); return w32(err); }); } catch (err) { AegLogger.error(AegRsa.TAG, 'ohAegRsaEncText fail, err code: ' + err.code + ', err msg: ' + err.message); return w32(err); } }); } static async ohAegRsaDecText(n32, priKey) { return new Promise(async (p32, q32) => { try { AegRsa.ohAegRsaDec(n32, priKey).then((data) => { let t32 = uint8ArrayToString(data); return p32(t32); }).catch((err) => { AegLogger.error(AegRsa.TAG, 'ohAegRsaDecText ohAegRsaDec fail, err code: ' + err.code + ', err msg: ' + err.message); return q32(err); }); } catch (err) { AegLogger.error(AegRsa.TAG, 'ohAegRsaDecText fail, err code: ' + err.code + ', err msg: ' + err.message); return q32(err); } }); } static async ohAegRsaEncTextHex(text, pubKey) { return new Promise(async (i32, j32) => { try { let k32 = getStrOrUint8ToUint8(text); AegRsa.ohAegRsaEncHex(k32, pubKey).then((data) => { return i32(data); }).catch((err) => { AegLogger.error(AegRsa.TAG, 'ohAegRsaEncText ohAegRsaEncHex fail, err code: ' + err.code + ', err msg: ' + err.message); return j32(err); }); } catch (err) { AegLogger.error(AegRsa.TAG, 'ohAegRsaEncText fail, err code: ' + err.code + ', err msg: ' + err.message); return j32(err); } }); } static async ohAegRsaDecTextHex(a32, priKey) { return new Promise(async (c32, d32) => { try { AegRsa.ohAegRsaDec(a32, priKey).then((data) => { let g32 = uint8ArrayToString(data); return c32(g32); }).catch((err) => { AegLogger.error(AegRsa.TAG, 'ohAegRsaDecTextHex ohAegRsaDec fail, err code: ' + err.code + ', err msg: ' + err.message); return d32(err); }); } catch (err) { AegLogger.error(AegRsa.TAG, 'ohAegRsaDecTextHex fail, err code: ' + err.code + ', err msg: ' + err.message); return d32(err); } }); } static async ohAegRsaEncHex(text, pubKey) { return new Promise(async (t31, u31) => { try { let v31 = AegRsa.getUint8Array(text); let w31 = AegRsa.Base64ToUint8Array(pubKey); let x31 = await AsyCipher .builder() .withCipherAlg(CipherAlg.RSA_OAEP_SHA256_MGF1_SHA256) .withPubKey(w31) .build(); x31.getEncryptHandler().from(v31).to().then((data) => { let result = Coder.BASE64.encode(data); t31(result); }).catch((err) => { AegLogger.error(AegRsa.TAG, 'ohAegRsaEncHex getEncryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); u31(err); }); } catch (err) { AegLogger.error(AegRsa.TAG, 'ohAegRsaEncHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); u31(err); } }); } static async ohAegRsaEnc(text, pubKey) { return new Promise(async (l31, m31) => { try { let n31 = AegRsa.getUint8Array(text); let o31 = AegRsa.Base64ToUint8Array(pubKey); let p31 = await AsyCipher .builder() .withCipherAlg(CipherAlg.RSA_OAEP_SHA256_MGF1_SHA256) .withPubKey(o31) .build(); p31.getEncryptHandler().from(n31).to().then((data) => { l31(data); }).catch((err) => { AegLogger.error(AegRsa.TAG, 'ohAegRsaEnc getEncryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); m31(err); }); } catch (err) { AegLogger.error(AegRsa.TAG, 'ohAegRsaEnc parse fail, err code: ' + err.code + ', err msg: ' + err.message); m31(err); } }); } static async ohAegRsaDecHex(text, priKey) { return new Promise(async (d31, e31) => { try { let f31 = AegRsa.Base64ToUint8Array(text); let g31 = AegRsa.Base64ToUint8Array(priKey); let h31 = await AsyCipher .builder() .withCipherAlg(CipherAlg.RSA_OAEP_SHA256_MGF1_SHA256) .withPriKey(g31) .build(); h31.getDecryptHandler().from(f31).to().then((data) => { let result = Coder.HEX.encode(data); d31(result); }).catch((err) => { AegLogger.error(AegRsa.TAG, 'ohAegRsaDecHex getDecryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); e31(err); }); } catch (err) { AegLogger.error(AegRsa.TAG, 'ohAegRsaDecHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); e31(err); } }); } static async ohAegRsaDec(text, priKey) { return new Promise(async (v30, w30) => { try { let x30 = AegRsa.Base64ToUint8Array(text); let y30 = AegRsa.Base64ToUint8Array(priKey); let z30 = await AsyCipher .builder() .withCipherAlg(CipherAlg.RSA_OAEP_SHA256_MGF1_SHA256) .withPriKey(y30) .build(); z30.getDecryptHandler().from(x30).to().then((data) => { v30(data); }).catch((err) => { AegLogger.error(AegRsa.TAG, 'ohAegRsaDec getDecryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); w30(err); }); } catch (err) { AegLogger.error(AegRsa.TAG, 'ohAegRsaDec parse fail, err code: ' + err.code + ', err msg: ' + err.message); w30(err); } }); } static getUint8Array(input) { if (input instanceof Uint8Array) { return input; } else { return Coder.HEX.decode(input); } } static Base64ToUint8Array(input) { if (input instanceof Uint8Array) { return input; } else { return Coder.BASE64.decode(input); } } } AegRsa.TAG = 'aegis AegRsa'; export class Rsa { constructor(publicKey, t30) { this.publicKey = publicKey; this.privateKey = t30; } } 