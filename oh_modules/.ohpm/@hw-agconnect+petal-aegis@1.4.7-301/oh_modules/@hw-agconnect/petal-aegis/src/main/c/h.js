import { AESCipher, CipherAlg, Coder } from "../ets/a/b"; import { AegLogger } from "./c2/d2"; import { SafeRandom } from "./e"; import { getStrOrUint8ToUint8, uint8ArrayToString } from "./q/s2"; export class AegAesCbc { static async ohAegAesCbcEncText(text, key, iv) { return new Promise(async (c11, d11) => { try { let e11 = getStrOrUint8ToUint8(text); AegAesCbc.ohAegAesCbcEnc(e11, key, iv).then((data) => { return c11(data); }).catch((err) => { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcEncText ohAegAesCbcEnc fail, err code: ' + err.code + ', err msg: ' + err.message); return d11(err); }); } catch (err) { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcEncText fail, err code: ' + err.code + ', err msg: ' + err.message); return d11(err); } }); } static async ohAegAesCbcDecText(u10, key) { return new Promise(async (w10, x10) => { try { AegAesCbc.ohAegAesCbcDec(u10, key).then((data) => { let a11 = uint8ArrayToString(data); return w10(a11); }).catch((err) => { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcDecText ohAegAesCbcDec fail, err code: ' + err.code + ', err msg: ' + err.message); return x10(err); }); } catch (err) { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcDecText fail, err code: ' + err.code + ', err msg: ' + err.message); return x10(err); } }); } static async ohAegAesCbcEncTextHex(text, key, iv) { return new Promise(async (p10, q10) => { try { let r10 = getStrOrUint8ToUint8(text); AegAesCbc.ohAegAesCbcEncHex(r10, key, iv).then((data) => { return p10(data); }).catch((err) => { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcEncText ohAegAesCbcEnc fail, err code: ' + err.code + ', err msg: ' + err.message); return q10(err); }); } catch (err) { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcEncText fail, err code: ' + err.code + ', err msg: ' + err.message); return q10(err); } }); } static async ohAegAesCbcDecTextHex(h10, key) { return new Promise(async (j10, k10) => { try { AegAesCbc.ohAegAesCbcDec(h10, key).then((data) => { let n10 = uint8ArrayToString(data); return j10(n10); }).catch((err) => { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcDecTextHex ohAegAesCbcDec fail, err code: ' + err.code + ', err msg: ' + err.message); return k10(err); }); } catch (err) { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcDecTextHex fail, err code: ' + err.code + ', err msg: ' + err.message); return k10(err); } }); } static async ohAegAesCbcEncHex(text, key, iv) { return new Promise(async (z9, a10) => { try { let b10 = new Uint8Array(); if (iv) { b10 = AegAesCbc.getUint8Array(iv); } else { b10 = SafeRandom.ohAegRandom(AegAesCbc.IV_LEN); } let c10 = AegAesCbc.getUint8Array(text); let d10 = AegAesCbc.getUint8Array(key); let e10 = await AESCipher .builder() .withCipherAlg(CipherAlg.AES_CBC_PKCS7_PADDING) .withKeyBytes(d10) .withIv(b10) .build(); e10.getEncryptHandler().from(c10).toHex().then((data) => { let result = Coder.HEX.encode(b10) + ':' + data; z9(result); }).catch((err) => { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcEncNoIvHex getEncryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); a10(err); }); } catch (err) { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcEncNoIvHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); a10(err); } }); } static async ohAegAesCbcEnc(text, key, iv) { return new Promise(async (p9, q9) => { try { let r9 = new Uint8Array(); if (iv) { r9 = AegAesCbc.getUint8Array(iv); } else { r9 = SafeRandom.ohAegRandom(AegAesCbc.IV_LEN); } let s9 = AegAesCbc.getUint8Array(text); let t9 = AegAesCbc.getUint8Array(key); let u9 = await AESCipher .builder() .withCipherAlg(CipherAlg.AES_CBC_PKCS7_PADDING) .withKeyBytes(t9) .withIv(r9) .build(); u9.getEncryptHandler().from(s9).to().then((data) => { let x9 = Coder.UTF8.decode(':'); let result = new Uint8Array(r9.length + data.length + x9.length); result.set(r9, 0); result.set(x9, r9.length); result.set(data, r9.length + x9.length); p9(result); }).catch((err) => { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcEncNoIvHex getEncryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); q9(err); }); } catch (err) { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcEncNoIvHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); q9(err); } }); } static async ohAegAesCbcDecHex(text, key) { return new Promise(async (h9, i9) => { try { let j9 = AegAesCbc.getCiphertextUint8Array(text); let k9 = AegAesCbc.getUint8Array(key); let l9 = await AESCipher .builder() .withCipherAlg(CipherAlg.AES_CBC_PKCS7_PADDING) .withKeyBytes(k9) .withIv(j9.iv) .build(); l9.getDecryptHandler().from(j9.text).toHex().then((data) => { h9(data); }).catch((err) => { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcDecHex getDecryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); i9(err); }); } catch (err) { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcDecHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); i9(err); } }); } static async ohAegAesCbcDec(text, key) { return new Promise(async (z8, a9) => { try { let b9 = AegAesCbc.getCiphertextUint8Array(text); let c9 = AegAesCbc.getUint8Array(key); let d9 = await AESCipher.builder() .withCipherAlg(CipherAlg.AES_CBC_PKCS7_PADDING) .withKeyBytes(c9) .withIv(b9.iv) .build(); d9.getDecryptHandler().from(b9.text).to().then((data) => { z8(data); }).catch((err) => { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcDec getDecryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); a9(err); }); } catch (err) { AegLogger.error(AegAesCbc.TAG, 'ohAegAesCbcDec parse fail, err code: ' + err.code + ', err msg: ' + err.message); a9(err); } }); } static getUint8Array(input) { if (input instanceof Uint8Array) { return input; } else { return Coder.HEX.decode(input); } } static getCiphertextUint8Array(input) { if (input instanceof Uint8Array) { let iv = input.subarray(0, AegAesCbc.IV_LEN); let x8 = input.subarray(AegAesCbc.IV_LEN + 1, input.length); return new CbcCiphertext(iv, x8); } else { let iv = Coder.HEX.decode(input.substring(0, AegAesCbc.IV_LEN * 2)); let w8 = Coder.HEX.decode(input.substring((AegAesCbc.IV_LEN * 2) + 1, input.length)); return new CbcCiphertext(iv, w8); } } } AegAesCbc.TAG = 'aegis AegAesCbc'; AegAesCbc.IV_LEN = 16; export class CbcCiphertext { constructor(iv, text) { this.iv = iv; this.text = text; } } 