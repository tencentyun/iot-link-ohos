import cryptoFramework from '@ohos.security.cryptoFramework'; import { AegLogger } from "./c2/d2"; import { uint8ArraytoHexString } from "./q/s2"; import { Coder } from "../ets/a/b"; import util from '@ohos.util'; export class PbkdfUtil { static ohAegPbkdf2Sha256Uint8Array(text, salt, x42) { return new Promise(async (z42, a43) => { try { let b43 = PbkdfUtil.checkIteration(x42); if (b43 === 0) { return a43('iteration not in [1000, 10000000]'); } if (text.length === 0) { let msg = 'ohAegPbkdf2Sha256Uint8Array text is empty'; AegLogger.error(PbkdfUtil.TAG, msg); return a43(msg); } let c43 = PbkdfUtil.getUint8Array(salt); if (!PbkdfUtil.checkLen(c43, PbkdfUtil.SALT_SIZE)) { let msg = 'ohAegPbkdf2Sha256Uint8Array salt len less than 16'; AegLogger.error(PbkdfUtil.TAG, msg); return a43(msg); } await PbkdfUtil.pbkdf2Sha256(text, c43, b43).then((data) => { return z42(data); }).catch((err) => { AegLogger.error(PbkdfUtil.TAG, err.message); return a43(err); }); } catch (err) { AegLogger.error(PbkdfUtil.TAG, 'ohAegPbkdf2Sha256Uint8Array fail : err message: ' + err.message + ', err code: ' + err.code); return a43(err); } }); } static ohAegPbkdf2Sha256(text, salt, o42) { return new Promise(async (q42, r42) => { try { let s42 = PbkdfUtil.checkIteration(o42); if (s42 === 0) { return r42('iteration not in [1000, 10000000]'); } if (text.length === 0) { let msg = 'ohAegPbkdf2Sha256 text is empty'; AegLogger.error(PbkdfUtil.TAG, msg); return r42(msg); } let t42 = PbkdfUtil.getUint8Array(salt); if (!PbkdfUtil.checkLen(t42, PbkdfUtil.SALT_SIZE)) { let msg = 'ohAegPbkdf2Sha256 salt len less than 16'; AegLogger.error(PbkdfUtil.TAG, msg); return r42(msg); } await PbkdfUtil.pbkdf2Sha256(text, t42, s42).then((data) => { let w42 = uint8ArraytoHexString(data); return q42(w42); }).catch((err) => { AegLogger.error(PbkdfUtil.TAG, err.message); return r42(err); }); } catch (err) { AegLogger.error(PbkdfUtil.TAG, 'ohAegPbkdf2Sha256 fail : err message: ' + err.message + ', err code: ' + err.code); return r42(err); } }); } static ohAegRootKey(first, second, c42, salt) { return new Promise(async (e42, f42) => { try { if (first.length === 0 || second.length === 0 || c42.length === 0 || salt.length === 0) { let msg = 'ohAegRootKey first or second or third or salt is empty'; AegLogger.error(PbkdfUtil.TAG, msg); return f42(msg); } let g42 = PbkdfUtil.getUint8Array(first); let h42 = PbkdfUtil.getUint8Array(second); let i42 = PbkdfUtil.getUint8Array(c42); let j42 = PbkdfUtil.getUint8Array(salt); if (!PbkdfUtil.checkRootKeyLen(g42, h42, i42, j42)) { let msg = 'ohAegRootKey first or second or third or salt len is not true'; AegLogger.error(PbkdfUtil.TAG, msg); return f42(msg); } let k42 = PbkdfUtil.charXor(g42, h42, i42); if (!k42) { let msg = 'ohAegRootKey charXor is failed'; AegLogger.error(PbkdfUtil.TAG, msg); return f42(msg); } PbkdfUtil.pbkdf2Sha256(k42, j42, PbkdfUtil.DEFAULT_ITERATION).then((data) => { let n42 = uint8ArraytoHexString(data); return e42(n42); }).catch((err) => { AegLogger.error(PbkdfUtil.TAG, err.message); return f42(err); }); } catch (err) { AegLogger.error(PbkdfUtil.TAG, 'ohAegRootKey fail : err message: ' + err.message + ', err code: ' + err.code); return f42(err); } }); } static ohAegRootKeyUint8Array(p41, q41, r41, salt) { return new Promise(async (t41, u41) => { try { if (!PbkdfUtil.checkInputIsEmpty(p41, q41, r41, salt)) { let msg = 'ohAegRootKeyUint8Array first or second or third or salt is empty'; AegLogger.error(PbkdfUtil.TAG, msg); return u41(msg); } let v41 = PbkdfUtil.getUint8Array(p41); let w41 = PbkdfUtil.getUint8Array(q41); let x41 = PbkdfUtil.getUint8Array(r41); let y41 = PbkdfUtil.getUint8Array(salt); if (!PbkdfUtil.checkRootKeyLen(v41, w41, x41, y41)) { let msg = 'ohAegRootKey first or second or third or salt len is not true'; AegLogger.error(PbkdfUtil.TAG, msg); return u41(msg); } let z41 = PbkdfUtil.charXor(v41, w41, x41); if (!z41) { let msg = 'ohAegRootKey charXor is failed'; AegLogger.error(PbkdfUtil.TAG, msg); return u41(msg); } PbkdfUtil.pbkdf2Sha256(z41, y41, PbkdfUtil.DEFAULT_ITERATION).then((data) => { return t41(data); }).catch((err) => { AegLogger.error(PbkdfUtil.TAG, err.message); return u41(err); }); } catch (err) { AegLogger.error(PbkdfUtil.TAG, 'ohAegRootKey fail : err message: ' + err.message + ', err code: ' + err.code); return u41(err); } }); } static checkInputIsEmpty(first, second, o41, salt) { try { if (first.length === 0) { let msg = 'checkInputIsEmpty first is empty'; AegLogger.error(PbkdfUtil.TAG, msg); return false; } if (second.length === 0) { let msg = 'checkInputIsEmpty second is empty'; AegLogger.error(PbkdfUtil.TAG, msg); return false; } if (o41.length === 0) { let msg = 'checkInputIsEmpty third is empty'; AegLogger.error(PbkdfUtil.TAG, msg); return false; } if (salt.length === 0) { let msg = 'checkInputIsEmpty salt is empty'; AegLogger.error(PbkdfUtil.TAG, msg); return false; } return true; } catch (err) { AegLogger.error(PbkdfUtil.TAG, 'checkInputIsEmpty fail : err message: ' + err.message + ', err code: ' + err.code); return false; } } static checkIteration(n41) { try { if (n41) { if (n41 < PbkdfUtil.MIN_ITERATION || n41 > PbkdfUtil.MAX_ITERATION) { AegLogger.error(PbkdfUtil.TAG, 'checkIteration fail : iteration not in :' + PbkdfUtil.MIN_ITERATION + ', ' + PbkdfUtil.MAX_ITERATION); return 0; } return n41; } else { return PbkdfUtil.DEFAULT_ITERATION; } } catch (err) { AegLogger.error(PbkdfUtil.TAG, 'checkIteration fail : err message: ' + err.message + ', err code: ' + err.code); return 0; } } static checkRootKeyLen(first, second, m41, salt) { try { if (!PbkdfUtil.checkLen(salt, PbkdfUtil.SALT_SIZE)) { let msg = 'ohAegRootKey salt len less than 16, len is ' + salt.length.toString(); AegLogger.error(PbkdfUtil.TAG, msg); return false; } if (!PbkdfUtil.checkLen(first, PbkdfUtil.KEY_SIZE)) { let msg = 'ohAegRootKey first len less than 32, len is ' + first.length.toString(); AegLogger.error(PbkdfUtil.TAG, msg); return false; } if (!PbkdfUtil.checkLen(second, PbkdfUtil.KEY_SIZE)) { let msg = 'ohAegRootKey second len less than 32, len is ' + second.length.toString(); AegLogger.error(PbkdfUtil.TAG, msg); return false; } if (!PbkdfUtil.checkLen(m41, PbkdfUtil.KEY_SIZE)) { let msg = 'ohAegRootKey third len less than 32, len is ' + m41.length.toString(); AegLogger.error(PbkdfUtil.TAG, msg); return false; } return true; } catch (err) { AegLogger.error(PbkdfUtil.TAG, 'checkRootKeyLen fail : err message: ' + err.message + ', err code: ' + err.code); return false; } } static checkLen(input, len) { try { if (input.length < len) { return false; } return true; } catch (err) { AegLogger.error(PbkdfUtil.TAG, 'checkLen fail : err message: ' + err.message + ', err code: ' + err.code); return false; } } static charXor(first, second, h41) { try { let i41 = Math.min(first.length, second.length, h41.length); let j41 = new Uint8Array(i41); for (let l41 = 0; l41 < i41; l41++) { j41[l41] = first[l41] ^ second[l41] ^ h41[l41]; } let k41 = PbkdfUtil.getUtf8Array(j41); return k41; } catch (err) { AegLogger.error(PbkdfUtil.TAG, 'charXor fail : err message: ' + err.message + ', err code: ' + err.code); return new Uint8Array(); } } static pbkdf2Sha256(text, salt, iterations) { return new Promise(async (b41, c41) => { try { let d41 = cryptoFramework.createKdf(PbkdfUtil.INIT_KDF); let spec = { algName: PbkdfUtil.ALG_NAME, password: text, salt: salt, iterations: iterations, keySize: PbkdfUtil.KEY_SIZE }; await d41.generateSecret(spec).then((g41) => { b41(g41.data); }).catch((error) => { AegLogger.error(PbkdfUtil.TAG, 'pbkdf2Sha256 generateSecret fail : err message: ' + error.message + ', err code: ' + error.code); c41(error); }); } catch (err) { AegLogger.error(PbkdfUtil.TAG, 'pbkdf2Sha256 fail : err message: ' + err.message + ', err code: ' + err.code); c41(err); } }); } static getUint8Array(input) { if (input instanceof Uint8Array) { return input; } else { return Coder.HEX.decode(input); } } static getUtf8Array(input) { try { let v40 = []; for (let y40 = 0; y40 < input.length; y40++) { let z40 = (input[y40] & 0x80) ? (0xff00 | input[y40]) : input[y40]; v40[y40] = String.fromCharCode(z40); } let w40 = v40.join(''); let x40 = new util.TextEncoder("utf-8"); let buffer = new ArrayBuffer(10); let result = new Uint8Array(buffer); result = x40.encodeInto(w40); return result; } catch (err) { AegLogger.error(PbkdfUtil.TAG, 'getUtf8Array fail : err message: ' + err.message + ', err code: ' + err.code); return new Uint8Array(); } } } PbkdfUtil.TAG = 'aegis PbkdfUtil'; PbkdfUtil.DEFAULT_ITERATION = 10000; PbkdfUtil.MIN_ITERATION = 1000; PbkdfUtil.MAX_ITERATION = 10010000; PbkdfUtil.KEY_SIZE = 32; PbkdfUtil.SALT_SIZE = 16; PbkdfUtil.INIT_KDF = 'PBKDF2|SHA256'; PbkdfUtil.ALG_NAME = 'PBKDF2'; 