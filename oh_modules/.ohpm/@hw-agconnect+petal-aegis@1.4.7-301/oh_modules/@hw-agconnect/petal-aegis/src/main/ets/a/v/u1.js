import { AESCipher } from "../y/e1/g1/h1"; import { CipherAlg } from "../y/e1/i1"; import { Coder } from "../y/s1/t1"; import { AegisError } from "../s/t"; import { AegisErrorCode } from "../s/u"; import { SecureRandom } from "./x"; const DEFAULT_GCM_IV_LEN = 12; const DEFAULT_AEGIS_STRING_CIPHER_KEY_ALIAS = 'aegis-string-cipher'; const SEPARATOR = ':'; const CIPHER_TEXT_SPLIT_LEN = 3; const CIPHER_TEXT_INDEX = 1; const IV_INDEX = 2; const VERSION_HUKS_AES_GCM_256_NO_PADDING = 1; export class StringCipher { constructor(t8, alias) { this.coder = t8; this.alias = alias; } async encrypt(data) { const iv = SecureRandom.generateRandom(DEFAULT_GCM_IV_LEN); let r8 = await AESCipher .builder() .withCipherAlg(CipherAlg.HUKS_AES_GCM_256_NO_PADDING) .withKeyAlias(this.alias) .withIv(iv) .build(); let s8 = await r8.getEncryptHandler().from(data).to(); return `${VERSION_HUKS_AES_GCM_256_NO_PADDING}${SEPARATOR}${this.coder.encode(s8)}${SEPARATOR}${this.coder.encode(iv)}`; } async encryptFromString(data) { return await this.encrypt(Coder.UTF8.decode(data)); } async decrypt(data) { let o8 = data.split(SEPARATOR); if (o8.length !== CIPHER_TEXT_SPLIT_LEN) { throw new AegisError(AegisErrorCode.PARAM_INVALID, 'bad cipher text'); } const iv = this.coder.decode(o8[IV_INDEX]); const p8 = this.coder.decode(o8[CIPHER_TEXT_INDEX]); let q8 = await AESCipher .builder() .withCipherAlg(CipherAlg.HUKS_AES_GCM_256_NO_PADDING) .withKeyAlias(this.alias) .withIv(iv) .build(); return await q8.getDecryptHandler().from(p8).to(); } async decryptToString(data) { return Coder.UTF8.encode(await this.decrypt(data)); } } StringCipher.HEX = new StringCipher(Coder.HEX, DEFAULT_AEGIS_STRING_CIPHER_KEY_ALIAS); StringCipher.HEX_UPPER_CASE = new StringCipher(Coder.HEX_UPPER_CASE, DEFAULT_AEGIS_STRING_CIPHER_KEY_ALIAS); StringCipher.BASE64 = new StringCipher(Coder.BASE64, DEFAULT_AEGIS_STRING_CIPHER_KEY_ALIAS); 