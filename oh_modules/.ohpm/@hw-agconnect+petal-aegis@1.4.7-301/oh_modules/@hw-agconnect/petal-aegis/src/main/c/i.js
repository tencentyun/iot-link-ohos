import { AESCipher, CipherAlg, Coder } from "../ets/a/b"; import { AegLogger } from "./c2/d2"; import { SafeRandom } from "./e"; import { getStrOrUint8ToUint8, uint8ArrayToString } from "./q/s2"; export class AegAesGcm { static async ohAegAesGcmEncText(text, key, iv) { return new Promise(async (n13, o13) => { try { let p13 = getStrOrUint8ToUint8(text); AegAesGcm.ohAegAesGcmEnc(p13, key, iv).then((data) => { return n13(data); }).catch((err) => { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmEncText ohAegAesGcmEnc fail, err code: ' + err.code + ', err msg: ' + err.message); return o13(err); }); } catch (err) { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmEncText fail, err code: ' + err.code + ', err msg: ' + err.message); return o13(err); } }); } static async ohAegAesGcmDecText(f13, key) { return new Promise(async (h13, i13) => { try { AegAesGcm.ohAegAesGcmDec(f13, key).then((data) => { let l13 = uint8ArrayToString(data); return h13(l13); }).catch((err) => { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmDecText ohAegAesGcmDec fail, err code: ' + err.code + ', err msg: ' + err.message); return i13(err); }); } catch (err) { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmDecText fail, err code: ' + err.code + ', err msg: ' + err.message); return i13(err); } }); } static async ohAegAesGcmEncTextHex(text, key, iv) { return new Promise(async (a13, b13) => { try { let c13 = getStrOrUint8ToUint8(text); AegAesGcm.ohAegAesGcmEncHex(c13, key, iv).then((data) => { return a13(data); }).catch((err) => { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmEncText ohAegAesGcmEncHex fail, err code: ' + err.code + ', err msg: ' + err.message); return b13(err); }); } catch (err) { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmEncText fail, err code: ' + err.code + ', err msg: ' + err.message); return b13(err); } }); } static async ohAegAesGcmDecTextHex(s12, key) { return new Promise(async (u12, v12) => { try { AegAesGcm.ohAegAesGcmDec(s12, key).then((data) => { let y12 = uint8ArrayToString(data); return u12(y12); }).catch((err) => { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmDecTextHex ohAegAesGcmDec fail, err code: ' + err.code + ', err msg: ' + err.message); return v12(err); }); } catch (err) { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmDecTextHex fail, err code: ' + err.code + ', err msg: ' + err.message); return v12(err); } }); } static async ohAegAesGcmEncHex(text, key, iv) { return new Promise(async (k12, l12) => { try { let m12 = new Uint8Array(); if (iv) { m12 = AegAesGcm.getUint8Array(iv); } else { m12 = SafeRandom.ohAegRandom(AegAesGcm.IV_LEN); } let n12 = AegAesGcm.getUint8Array(text); let o12 = AegAesGcm.getUint8Array(key); let p12 = await AESCipher .builder() .withCipherAlg(CipherAlg.AES_GCM_NO_PADDING) .withKeyBytes(o12) .withIv(m12) .build(); p12.getEncryptHandler().from(n12).toHex().then((data) => { let result = Coder.HEX.encode(m12) + ':' + data; k12(result); }).catch((err) => { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmEncNoIvHex getEncryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); l12(err); }); } catch (err) { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmEncNoIvHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); l12(err); } }); } static async ohAegAesGcmEnc(text, key, iv) { return new Promise(async (a12, b12) => { try { let c12 = new Uint8Array(); if (iv) { c12 = AegAesGcm.getUint8Array(iv); } else { c12 = SafeRandom.ohAegRandom(AegAesGcm.IV_LEN); } let d12 = AegAesGcm.getUint8Array(text); let e12 = AegAesGcm.getUint8Array(key); let f12 = await AESCipher .builder() .withCipherAlg(CipherAlg.AES_GCM_NO_PADDING) .withKeyBytes(e12) .withIv(c12) .build(); f12.getEncryptHandler().from(d12).to().then((data) => { let i12 = Coder.UTF8.decode(':'); let result = new Uint8Array(c12.length + data.length + i12.length); result.set(c12, 0); result.set(i12, c12.length); result.set(data, c12.length + i12.length); a12(result); }).catch((err) => { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmEncNoIvHex getEncryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); b12(err); }); } catch (err) { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmEncNoIvHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); b12(err); } }); } static async ohAegAesGcmDecHex(text, key) { return new Promise(async (s11, t11) => { try { let u11 = AegAesGcm.getCiphertextUint8Array(text); let v11 = AegAesGcm.getUint8Array(key); let w11 = await AESCipher .builder() .withCipherAlg(CipherAlg.AES_GCM_NO_PADDING) .withKeyBytes(v11) .withIv(u11.iv) .build(); w11.getDecryptHandler().from(u11.text).toHex().then((data) => { s11(data); }).catch((err) => { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmDecHex getDecryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); t11(err); }); } catch (err) { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmDecHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); t11(err); } }); } static async ohAegAesGcmDec(text, key) { return new Promise(async (k11, l11) => { try { let m11 = AegAesGcm.getCiphertextUint8Array(text); let n11 = AegAesGcm.getUint8Array(key); let o11 = await AESCipher .builder() .withCipherAlg(CipherAlg.AES_GCM_NO_PADDING) .withKeyBytes(n11) .withIv(m11.iv) .build(); o11.getDecryptHandler().from(m11.text).to().then((data) => { k11(data); }).catch((err) => { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmDec getDecryptHandler fail, err code: ' + err.code + ', err msg: ' + err.message); l11(err); }); } catch (err) { AegLogger.error(AegAesGcm.TAG, 'ohAegAesGcmDec parse fail, err code: ' + err.code + ', err msg: ' + err.message); l11(err); } }); } static getUint8Array(input) { if (input instanceof Uint8Array) { return input; } else { return Coder.HEX.decode(input); } } static getCiphertextUint8Array(input) { if (input instanceof Uint8Array) { let iv = input.subarray(0, AegAesGcm.IV_LEN); let i11 = input.subarray(AegAesGcm.IV_LEN + 1, input.length); return new Ciphertext(iv, i11); } else { let iv = Coder.HEX.decode(input.substring(0, AegAesGcm.IV_LEN * 2)); let h11 = Coder.HEX.decode(input.substring((AegAesGcm.IV_LEN * 2) + 1, input.length)); return new Ciphertext(iv, h11); } } } AegAesGcm.TAG = 'aegis AegAesGcm'; AegAesGcm.IV_LEN = 12; export class Ciphertext { constructor(iv, text) { this.iv = iv; this.text = text; } } 