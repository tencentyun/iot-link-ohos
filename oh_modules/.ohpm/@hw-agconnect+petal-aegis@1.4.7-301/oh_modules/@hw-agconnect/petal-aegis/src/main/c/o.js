import { AsySigner, Coder, KeyManager, KeyType, SignAlg } from "../ets/a/b"; import { AegLogger } from "./c2/d2"; import { getStrOrUint8ToUint8 } from "./q/s2"; export class AegEcc { static async ohAegGenEccKeyPairBase64() { return new Promise(async (t15, u15) => { try { KeyManager.generateKeyPair(KeyType.ECC_256).then((x15) => { let y15 = Coder.BASE64.encode(x15.priKey.getEncoded().data); let z15 = Coder.BASE64.encode(x15.pubKey.getEncoded().data); t15(new EccKeyPair(z15, y15)); }).catch((err) => { AegLogger.error(AegEcc.TAG, 'ohAegGenerateRsaKeyPair generateKeyPair fail, err code: ' + err.code + ', err msg: ' + err.message); u15(err); }); } catch (err) { AegLogger.error(AegEcc.TAG, 'ohAegGenerateRsaKeyPair parse fail, err code: ' + err.code + ', err msg: ' + err.message); u15(err); } }); } static async ohAegGenEccKeyPair() { return new Promise(async (l15, m15) => { try { KeyManager.generateKeyPair(KeyType.ECC_256).then((p15) => { let q15 = p15.priKey.getEncoded().data; let r15 = p15.pubKey.getEncoded().data; l15(new EccKeyPair(r15, q15)); }).catch((err) => { AegLogger.error(AegEcc.TAG, 'ohAegGenEccKeyPair generateKeyPair fail, err code: ' + err.code + ', err msg: ' + err.message); m15(err); }); } catch (err) { AegLogger.error(AegEcc.TAG, 'ohAegGenEccKeyPair parse fail, err code: ' + err.code + ', err msg: ' + err.message); m15(err); } }); } static async ohAegEccSignText(text, priKey) { return new Promise(async (f15, g15) => { try { let h15 = getStrOrUint8ToUint8(text); AegEcc.ohAegEccSign(h15, priKey).then((data) => { return f15(data); }).catch((err) => { AegLogger.error(AegEcc.TAG, 'ohAegAesGcmEncText ohAegEccSign fail, err code: ' + err.code + ', err msg: ' + err.message); return g15(err); }); } catch (err) { AegLogger.error(AegEcc.TAG, 'ohAegAesGcmEncText fail, err code: ' + err.code + ', err msg: ' + err.message); return g15(err); } }); } static async ohAegEccSignTextBase64(text, priKey) { return new Promise(async (z14, a15) => { try { let b15 = getStrOrUint8ToUint8(text); AegEcc.ohAegEccSignHex(b15, priKey).then((data) => { return z14(data); }).catch((err) => { AegLogger.error(AegEcc.TAG, 'ohAegEccSignTextBase64 ohAegEccSignHex fail, err code: ' + err.code + ', err msg: ' + err.message); return a15(err); }); } catch (err) { AegLogger.error(AegEcc.TAG, 'ohAegEccSignTextBase64 fail, err code: ' + err.code + ', err msg: ' + err.message); return a15(err); } }); } static async ohAegEccSignHex(text, priKey) { return new Promise(async (r14, s14) => { try { let t14 = AegEcc.getUint8Array(text); let u14 = AegEcc.Base64ToUint8Array(priKey); let v14 = await AsySigner .builder() .withSignAlg(SignAlg.ECDSA_SHA256) .withPriKey(u14) .build(); v14.getSignHandler().from(t14).toBase64().then((data) => { r14(data); }).catch((err) => { AegLogger.error(AegEcc.TAG, 'ohAegEccEncHex getSignHandler fail, err code: ' + err.code + ', err msg: ' + err.message); s14(err); }); } catch (err) { AegLogger.error(AegEcc.TAG, 'ohAegEccEncHex parse fail, err code: ' + err.code + ', err msg: ' + err.message); s14(err); } }); } static async ohAegEccSign(text, priKey) { return new Promise(async (j14, k14) => { try { let l14 = AegEcc.getUint8Array(text); let m14 = AegEcc.Base64ToUint8Array(priKey); let n14 = await AsySigner .builder() .withSignAlg(SignAlg.ECDSA_SHA256) .withPriKey(m14) .build(); n14.getSignHandler().from(l14).to().then((data) => { j14(data); }).catch((err) => { AegLogger.error(AegEcc.TAG, 'ohAegEccSign getSignHandler fail, err code: ' + err.code + ', err msg: ' + err.message); k14(err); }); } catch (err) { AegLogger.error(AegEcc.TAG, 'ohAegEccSign parse fail, err code: ' + err.code + ', err msg: ' + err.message); k14(err); } }); } static async ohAegEccVerifySign(text, pubKey, sign) { return new Promise(async (a14, b14) => { try { let c14 = AegEcc.getUint8Array(text); let d14 = AegEcc.Base64ToUint8Array(pubKey); let e14 = AegEcc.Base64ToUint8Array(sign); let f14 = await AsySigner.builder() .withSignAlg(SignAlg.ECDSA_SHA256) .withPubKey(d14) .build(); f14.getVerifyHandler().from(c14).verify(e14).then((data) => { a14(data); }).catch((err) => { AegLogger.error(AegEcc.TAG, 'ohAegEccVerifySign getVerifyHandler fail, err code: ' + err.code + ', err msg: ' + err.message); b14(err); }); } catch (err) { AegLogger.error(AegEcc.TAG, 'ohAegEccVerifySign parse fail, err code: ' + err.code + ', err msg: ' + err.message); b14(err); } }); } static async ohAegEccVerifySignText(text, pubKey, sign) { return new Promise(async (u13, v13) => { try { let w13 = getStrOrUint8ToUint8(text); AegEcc.ohAegEccVerifySign(w13, pubKey, sign).then((data) => { u13(data); }).catch((err) => { AegLogger.error(AegEcc.TAG, 'ohAegEccVerifySignText ohAegEccVerifySign fail, err code: ' + err.code + ', err msg: ' + err.message); v13(err); }); } catch (err) { AegLogger.error(AegEcc.TAG, 'ohAegEccVerifySignText parse fail, err code: ' + err.code + ', err msg: ' + err.message); v13(err); } }); } static getUint8Array(input) { if (input instanceof Uint8Array) { return input; } else { return Coder.HEX.decode(input); } } static Base64ToUint8Array(input) { if (input instanceof Uint8Array) { return input; } else { return Coder.BASE64.decode(input); } } } AegEcc.TAG = 'aegis AegEcc'; AegEcc.IV_LEN = 12; export class EccKeyPair { constructor(publicKey, s13) { this.publicKey = publicKey; this.privateKey = s13; } } 