import { AegisError } from "../../s/t"; import { AegisErrorCode } from "../../s/u"; import { Coder } from "../s1/t1"; import { KeyConverter } from "./c1"; export class AsyKeyBuilder { withKeyPair(u4) { this.keyPair = u4; return this; } withPriKey(priKey) { this.priKey = priKey; return this; } withPriKeyBase64(t4) { this.priKey = Coder.BASE64.decode(t4); return this; } withPriKeyHex(s4) { this.priKey = Coder.HEX.decode(s4); return this; } withPubKey(pubKey) { this.pubKey = pubKey; return this; } withPubKeyBase64(r4) { this.pubKey = Coder.BASE64.decode(r4); return this; } withPubKeyHex(q4) { this.pubKey = Coder.HEX.decode(q4); return this; } withCertPEM(p4) { this.certPEM = p4; return this; } withCertDER(o4) { this.certDER = o4; return this; } withCertDERBase64(n4) { return this.withCertDER(Coder.BASE64.decode(n4)); } withKeyAlias(keyAlias) { this.keyAlias = keyAlias; return this; } async initKeys() { var k4; if (this.keyAlias) { return; } if (this.keyPair) { return; } if (this.certPEM) { this.cert = await KeyConverter.fromCertPEM(this.certPEM); this.pubKey = this.cert.getPublicKey().getEncoded().data; } else if (this.certDER) { this.cert = await KeyConverter.fromCertDER(this.certDER); this.pubKey = this.cert.getPublicKey().getEncoded().data; } this.keyPair = await KeyConverter.fromKeyPair(this.getKeyType(), this.priKey, this.pubKey); let l4 = this.getRSANBits(); if (l4 === KeyConverter.DEFAULT_RSA_N_BITS) { return; } let key = (k4 = this.keyPair.priKey) !== null && k4 !== void 0 ? k4 : this.keyPair.pubKey; let m4 = KeyConverter.getRSANBitsOfKey(key); if (m4 !== KeyConverter.DEFAULT_RSA_N_BITS && m4 < l4) { throw new AegisError(AegisErrorCode.BAD_KEY_LEN, 'min n bits of RSA is 3072'); } } } 