import huks from '@ohos.security.huks'; import { Logger } from "../../../c2/d2"; import { AegisError } from "../../../s/t"; import { AegisErrorCode } from "../../../s/u"; import { KeyManager } from "../../z/b1"; import { CipherHandler } from "../b2"; import { CipherInfoCenter } from "../y1"; import { preprocessAuthParams } from "./z1"; export class HuksAESAuthCipherHandler extends CipherHandler { constructor(h2, mode, keyAlias, i2) { super(h2); this.mode = mode; this.keyAlias = keyAlias; this.paramsSpec = i2; } async initKey() { let g2 = await KeyManager.hasHuksKey(this.paramsSpec.keyType, this.keyAlias); if (g2) { return; } if (this.mode === huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT) { throw new AegisError(AegisErrorCode.CRYPTO_ERROR, `decrypt with a non-exist huks key:${this.keyAlias}`); } else { await KeyManager.generateHuksKey(this.paramsSpec.keyType, this.keyAlias); Logger.info(`generate huks key item for alias:${this.keyAlias}`); } } preprocess() { preprocessAuthParams(this.inputs, this.paramsSpec, this.mode === huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT); } async doCrypto(c2, d2) { await this.initKey(); this.preprocess(); let e2 = CipherInfoCenter.load(this.cipherAlg); this.paramsSpec.huksCryptoMode = this.mode; let options = e2.optionsFunc(this.paramsSpec); let handle = await huks.initSession(this.keyAlias, options); for (let input of this.inputs) { let start = 0; while (start < input.length) { const end = start + this.paramsSpec.blockMaxSize > input.length ? input.length : start + this.paramsSpec.blockMaxSize; options.inData = input.subarray(start, end); let f2 = await huks.updateSession(handle.handle, options); c2 === null || c2 === void 0 ? void 0 : c2.push(f2.outData); d2 === null || d2 === void 0 ? void 0 : d2.push(...f2.outData); start += this.paramsSpec.blockMaxSize; } } if (this.paramsSpec.huksCryptoMode === huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT) { options.inData = new Uint8Array(); let authTag = await huks.finishSession(handle.handle, options); c2 === null || c2 === void 0 ? void 0 : c2.push(authTag.outData); d2 === null || d2 === void 0 ? void 0 : d2.push(...authTag.outData); } else { options.inData = new Uint8Array(); await huks.finishSession(handle.handle, options); } } } 