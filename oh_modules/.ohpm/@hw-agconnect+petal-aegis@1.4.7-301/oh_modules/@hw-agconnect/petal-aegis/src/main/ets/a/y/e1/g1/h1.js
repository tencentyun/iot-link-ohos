import cryptoFramework from '@ohos.security.cryptoFramework'; import { AegisError } from "../../../s/t"; import { AegisErrorCode } from "../../../s/u"; import { Coder } from "../../s1/t1"; import { KeyConverter } from "../../z/c1"; import { KeyType } from "../../z/a1"; import { Cipher } from "../f1"; import { CipherAlg } from "../i1"; import { CipherInfoCenter } from "../y1"; import { AESAuthCipherHandler, AESCommonCipherHandler } from "./z1"; import { HuksAESCipher } from "./a2"; export class AESCipher extends Cipher { constructor(e1, key, f1) { super(e1); if (e1 === CipherAlg.AES_GCM_NO_PADDING || e1 === CipherAlg.AES_CCM_NO_PADDING) { this.encryptHandler = new AESAuthCipherHandler(e1, cryptoFramework.CryptoMode.ENCRYPT_MODE, key, f1); this.decryptHandler = new AESAuthCipherHandler(e1, cryptoFramework.CryptoMode.DECRYPT_MODE, key, f1); } else { this.encryptHandler = new AESCommonCipherHandler(e1, cryptoFramework.CryptoMode.ENCRYPT_MODE, key, f1); this.decryptHandler = new AESCommonCipherHandler(e1, cryptoFramework.CryptoMode.DECRYPT_MODE, key, f1); } } static builder() { return new AESCipherBuilder(); } } const DEFAULT_BLOCK_MAX_SIZE = 100 * 1024; class AESCipherBuilder { constructor() { this.blockMaxSize = DEFAULT_BLOCK_MAX_SIZE; } withCipherAlg(d1) { this.cipherAlg = d1; return this; } withKeyBytes(c1) { this.i = c1; return this; } withKeyHex(b1) { this.i = Coder.HEX.decode(b1); return this; } withKeyBase64(a1) { this.i = Coder.BASE64.decode(a1); return this; } withKeyAlias(keyAlias) { this.keyAlias = keyAlias; return this; } withIv(iv) { this.iv = iv; return this; } withIvHex(u) { this.iv = Coder.HEX.decode(u); return this; } withAad(aad) { this.aad = aad; return this; } withAadHex(t) { this.aad = Coder.HEX.decode(t); return this; } withAadBase64(s) { this.aad = Coder.BASE64.decode(s); return this; } withBlockMaxSize(o) { if (o < 0 || o > DEFAULT_BLOCK_MAX_SIZE) { throw new AegisError(AegisErrorCode.PARAM_INVALID, 'invalid block max size'); } this.blockMaxSize = o; return this; } async build() { var i; let j = CipherInfoCenter.load(this.cipherAlg); if (!j) { throw new AegisError(AegisErrorCode.PARAM_INVALID, 'invalid cipher alg'); } if (j.ivLen !== this.iv.length) { throw new AegisError(AegisErrorCode.PARAM_INVALID, 'invalid iv len'); } if (this.cipherAlg === CipherAlg.HUKS_AES_GCM_256_NO_PADDING) { let m = { algName: 'AES', blockMaxSize: this.blockMaxSize, keyType: KeyType.HUKS_AES_GCM_256, iv: { data: this.iv }, aad: { data: this.aad }, authTagLen: j.authTagLen }; return new HuksAESCipher(this.cipherAlg, this.keyAlias, m); } else { KeyConverter.checkAESKeyLen(this.i); let key = await KeyConverter.fromSymKey(this.i); let k = { algName: 'AES', blockMaxSize: this.blockMaxSize, iv: { data: this.iv }, aad: { data: (i = this.aad) !== null && i !== void 0 ? i : new Uint8Array() }, authTagLen: j.authTagLen }; return new AESCipher(this.cipherAlg, key, k); } } } 