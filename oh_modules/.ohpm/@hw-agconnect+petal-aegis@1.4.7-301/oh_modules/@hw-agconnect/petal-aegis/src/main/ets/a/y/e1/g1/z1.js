import cryptoFramework from '@ohos.security.cryptoFramework'; import { AegisError } from "../../../s/t"; import { AegisErrorCode } from "../../../s/u"; import { CipherHandler } from "../b2"; import { getTransformationIndexFromKey } from "../i1"; import { CipherInfoCenter } from "../y1"; const EMPTY_DATA = new Uint8Array(); export class AESCipherHandler extends CipherHandler { constructor(a2, mode, key, b2) { super(a2); this.mode = mode; this.key = key; this.paramsSpec = b2; } async init() { let z1 = CipherInfoCenter.load(this.cipherAlg); this.paramsSpec.algName = z1.paramsSpecAlgName; let index = getTransformationIndexFromKey(this.key); if (index >= z1.transformation.length) { throw new AegisError(AegisErrorCode.PARAM_INVALID, 'invalid key'); } let transformation = z1.transformation[index]; this.cipher = cryptoFramework.createCipher(transformation); await this.cipher.init(this.mode, this.key, this.paramsSpec); } async update(t1, u1) { for (let input of this.inputs) { let start = 0; while (start < input.length) { const end = start + this.paramsSpec.blockMaxSize > input.length ? input.length : start + this.paramsSpec.blockMaxSize; let v1 = await this.cipher.update({ data: input.subarray(start, end) }); let w1 = v1 ? v1.data : EMPTY_DATA; t1 === null || t1 === void 0 ? void 0 : t1.push(w1); u1 === null || u1 === void 0 ? void 0 : u1.push(...w1); start += this.paramsSpec.blockMaxSize; } } } async doCrypto(q1, s1) { await this.init(); await this.update(q1, s1); await this.final(q1, s1); } } export class AESCommonCipherHandler extends AESCipherHandler { async final(n1, o1) { let p1 = await this.cipher.doFinal({ data: new Uint8Array() }); if (p1) { n1 === null || n1 === void 0 ? void 0 : n1.push(p1 === null || p1 === void 0 ? void 0 : p1.data); o1 === null || o1 === void 0 ? void 0 : o1.push(...p1 === null || p1 === void 0 ? void 0 : p1.data); } } } export function preprocessAuthParams(inputs, k1, l1) { if (l1) { k1.authTag = { data: new Uint8Array(k1.authTagLen) }; } else { if (inputs.length === 1) { let len = inputs[0].length; let m1 = len - k1.authTagLen; let input = inputs[0].slice(0, m1); let authTag = inputs[0].slice(m1); inputs[0] = input; k1.authTag = { data: authTag }; } else { let authTag = inputs[inputs.length - 1]; k1.authTag = { data: authTag }; inputs.pop(); } } } export class AESAuthCipherHandler extends AESCipherHandler { async final(i1, j1) { if (this.mode === cryptoFramework.CryptoMode.ENCRYPT_MODE) { let authTag = await this.cipher.doFinal({ data: new Uint8Array() }); i1 === null || i1 === void 0 ? void 0 : i1.push(authTag.data); j1 === null || j1 === void 0 ? void 0 : j1.push(...authTag.data); } else { await this.cipher.doFinal(null); } } async doCrypto(g1, h1) { this.preprocess(); await super.doCrypto(g1, h1); } preprocess() { preprocessAuthParams(this.inputs, this.paramsSpec, this.mode === cryptoFramework.CryptoMode.ENCRYPT_MODE); } } 